<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV.Cuda</name>
    </assembly>
    <members>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG">
            <summary>
            Gaussian Mixture-based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Create a Gaussian Mixture-based Background/Foreground Segmentation model
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG.Update(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaInvoke">
            <summary>
            This class wraps the functional calls to the opencv_gpu module
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaDeviceInfoComputeCapability(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            Get the compute capability of the device
            </summary>
            <param name="device">The device</param>
            <param name="major">The major version of the compute capability</param>
            <param name="minor">The minor version of the compute capability</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaDeviceInfoMultiProcessorCount(System.IntPtr)">
            <summary>
            Get the number of multiprocessors on device
            </summary>
            <param name="device">The device</param>
            <returns>The number of multiprocessors on device</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaDeviceInfoDeviceName(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            Get the device name
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetCudaDevicesSummary">
            <summary>
            Get the opencl platform summary as a string
            </summary>
            <returns>An opencl platfor summary</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetCudaEnabledDeviceCount">
            <summary>
            Get the number of Cuda enabled devices
            </summary>
            <returns>The number of Cuda enabled devices</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SetDevice(System.Int32)">
            <summary>
            Set the current Gpu Device
            </summary>
            <param name="deviceId">The id of the device to be setted as current</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetDevice">
            <summary>
            Get the current Cuda device id
            </summary>
            <returns>The current Cuda device id</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetRegion(System.IntPtr,Emgu.CV.Structure.MCvSlice@,Emgu.CV.Structure.MCvSlice@)">
            <summary>
            Create a GpuMat from the specific region of <paramref name="gpuMat"/>. The data is shared between the two GpuMat.
            </summary>
            <param name="gpuMat">The gpuMat to extract regions from.</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GpuMatResize(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.Inter,System.IntPtr)">
            <summary>
            Resize the GpuMat
            </summary>
            <param name="src">The input GpuMat</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="interpolation">The interpolation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GpuMatReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            gpuMatReshape the src GpuMat  
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The resulting GpuMat, as input it should be an empty GpuMat.</param>
            <param name="cn">The new number of channels</param>
            <param name="rows">The new number of rows</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion,System.Int32,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="code">The color conversion code</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SwapChannels(Emgu.CV.IInputOutputArray,System.Int32[],Emgu.CV.Cuda.Stream)">
            <summary>
            Swap channels.
            </summary>
            <param name="src">The image where the channels will be swapped</param>
            <param name="dstOrder">
            Integer array describing how channel values are permutated. The n-th entry
            of the array contains the number of the channel that is stored in the n-th channel of
            the output image. E.g. Given an RGBA image, aDstOrder = [3,2,1,0] converts this to ABGR
            channel order.
            </param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetSubRect(System.IntPtr,System.Drawing.Rectangle@)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input GpuMat. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="mat">Input GpuMat</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>Pointer to the resultant sub-array header.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.LShift(System.IntPtr,Emgu.CV.Structure.MCvScalar@,System.IntPtr,System.IntPtr)">
            <summary>
            Shifts a matrix to the left (c = a &lt;&lt; scalar)
            </summary>
            <param name="a">The matrix to be shifted.</param>
            <param name="scalar">The scalar to shift by.</param>
            <param name="c">The result of the shift</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.RShift(System.IntPtr,Emgu.CV.Structure.MCvScalar@,System.IntPtr,System.IntPtr)">
            <summary>
            Shifts a matrix to the right (c = a >> scalar)
            </summary>
            <param name="a">The matrix to be shifted.</param>
            <param name="scalar">The scalar to shift by.</param>
            <param name="c">The result of the shift</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Add(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Adds one matrix to another (c = a + b).
            </summary>
            <param name="a">The first matrix to be added.</param>
            <param name="b">The second matrix to be added.</param>
            <param name="c">The sum of the two matrix</param>
            <param name="mask">The optional mask that is used to select a subarray. Use null if not needed</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Subtract(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Subtracts one matrix from another (c = a - b).
            </summary>
            <param name="a">The matrix where subtraction take place</param>
            <param name="b">The matrix to be substracted</param>
            <param name="c">The result of a - b</param>
            <param name="mask">The optional mask that is used to select a subarray. Use null if not needed</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Multiply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes element-wise product of the two GpuMat: c = scale * a * b.
            </summary>
            <param name="a">The first GpuMat to be element-wise multiplied.</param>
            <param name="b">The second GpuMat to be element-wise multiplied.</param>
            <param name="c">The element-wise multiplication of the two GpuMat</param>
            <param name="scale">The scale</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Divide(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes element-wise quotient of the two GpuMat (c = scale *  a / b).
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The element-wise quotient of the two GpuMat</param>
            <param name="scale">The scale</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.AddWeighted(Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes the weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="alpha">The weight for <paramref name="src1"/></param>
            <param name="src2">The second source GpuMat</param>
            <param name="beta">The weight for <paramref name="src2"/></param>
            <param name="gamma">The constant to be added</param>
            <param name="dst">The result</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Absdiff(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes element-wise absolute difference of two GpuMats (c = abs(a - b)).
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The result of the element-wise absolute difference.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Abs(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes absolute value of each pixel in an image
            </summary>
            <param name="src">The source GpuMat, support depth of Int16 and float.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Sqr(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes square of each pixel in an image
            </summary>
            <param name="src">The source GpuMat, support depth of byte, UInt16, Int16 and float.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Sqrt(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes square root of each pixel in an image
            </summary>
            <param name="src">The source GpuMat, support depth of byte, UInt16, Int16 and float.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Compare(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CmpType,Emgu.CV.Cuda.Stream)">
            <summary>
            Compares elements of two GpuMats (c = a &lt;cmpop&gt; b).
            Supports CV_8UC4, CV_32FC1 types
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The result of the comparison.</param>
            <param name="cmpop">The type of comparison</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Resize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.Cuda.Stream)">
            <summary>
            Resizes the image.
            </summary>
            <param name="src">The source image. Has to be GpuMat&lt;Byte&gt;. If stream is used, the GpuMat has to be either single channel or 4 channels.</param>
            <param name="dst">The destination image.</param>
            <param name="interpolation">The interpolation type. Supports INTER_NEAREST, INTER_LINEAR.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Split(Emgu.CV.IInputArray,Emgu.CV.Cuda.VectorOfGpuMat,Emgu.CV.Cuda.Stream)">
            <summary>
            Copies each plane of a multi-channel GpuMat to a dedicated GpuMat
            </summary>
            <param name="src">The multi-channel gpuMat</param>
            <param name="dstArray">Pointer to an array of single channel GpuMat pointers</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Merge(Emgu.CV.Cuda.VectorOfGpuMat,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Makes multi-channel GpuMat out of several single-channel GpuMats
            </summary>
            <param name="srcArr">Pointer to an array of single channel GpuMat pointers</param>
            <param name="dst">The multi-channel gpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Exp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes exponent of each matrix element (b = exp(a))
            </summary>
            <param name="src">The source GpuMat. Supports Byte, UInt16, Int16 and float type.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Pow(Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes power of each matrix element:
              (dst(i,j) = pow(     src(i,j) , power), if src.type() is integer;
              (dst(i,j) = pow(fabs(src(i,j)), power), otherwise.
            supports all, except depth == CV_64F
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="power">The power</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Log(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes natural logarithm of absolute value of each matrix element: b = log(abs(a))
            </summary>
            <param name="src">The source GpuMat. Supports Byte, UInt16, Int16 and float type.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Magnitude(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes magnitude of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MagnitudeSqr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes squared magnitude of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Phase(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes angle (angle(i)) of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="angle">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the output angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CartToPolar(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts Cartesian coordinates to polar
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="angle">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the output angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.PolarToCart(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts polar coordinates to Cartesian
            </summary>
            <param name="magnitude">The source GpuMat. Supports only floating-point type</param>
            <param name="angle">The source GpuMat. Supports only floating-point type</param>
            <param name="x">The destination GpuMat. Supports only floating-point type</param>
            <param name="y">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the input angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MinMaxLoc(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole GpuMat or, if mask is not IntPtr.Zero, in the specified GpuMat region.
            </summary>
            <param name="gpuMat">The source GpuMat, single-channel</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray. Use null if not needed</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.PyrDown(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. 
            </summary>
            <param name="src">The source CudaImage.</param>
            <param name="dst">The destination CudaImage, should have 2x smaller width and height than the source.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.PyrUp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition.
            </summary>
            <param name="src">The source CudaImage.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Computes mean value and standard deviation
            </summary>
            <param name="mtx">The GpuMat. Supports only CV_8UC1 type</param>
            <param name="mean">The mean value</param>
            <param name="stddev">The standard deviation</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.NormType)">
            <summary>
            Computes norm of the difference between two GpuMats
            </summary>
            <param name="src1">The GpuMat. Supports only CV_8UC1 type</param>
            <param name="src2">If IntPtr.Zero, norm operation is apply to <paramref name="src1"/> only. Otherwise, this is the GpuMat of type CV_8UC1</param>
            <param name="normType">The norm type. Supports NORM_INF, NORM_L1, NORM_L2.</param>
            <returns>The norm of the <paramref name="src1"/> if <paramref name="src2"/> is IntPtr.Zero. Otherwise the norm of the difference between two GpuMats.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CountNonZero(Emgu.CV.IInputArray)">
            <summary>
            Counts non-zero array elements
            </summary>
            <param name="src">The GpuMat</param>
            <returns>The number of non-zero GpuMat elements</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Reduce(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Reduces GpuMat to a vector by treating the GpuMat rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <param name="mtx">The input GpuMat</param>
            <param name="vec">The destination GpuMat. Must be preallocated 1 x n matrix and have the same number of channels as the input GpuMat</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="reduceOp">The reduction operation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaFlip(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
             <summary>
             Flips the GpuMat in one of different 3 ways (row and column indices are 0-based):
             dst(i,j)=src(rows(src)-i-1,j) if flip_mode = 0
             dst(i,j)=src(i,cols(src1)-j-1) if flip_mode &gt; 0
             dst(i,j)=src(rows(src)-i-1,cols(src)-j-1) if flip_mode &lt; 0
             </summary>
             <param name="src">Source GpuMat.</param>
             <param name="dst">Destination GpuMat.</param>
             <param name="flipMode">
             Specifies how to flip the GpuMat.
             flip_mode = 0 means flipping around x-axis, 
             flip_mode &gt; 0 (e.g. 1) means flipping around y-axis and 
             flip_mode &lt; 0 (e.g. -1) means flipping around both axises. 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Flip(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.FlipType,Emgu.CV.Cuda.Stream)">
            <summary>
            Flips the GpuMat&lt;Byte&gt; in one of different 3 ways (row and column indices are 0-based). 
            </summary>
            <param name="src">The source GpuMat. supports 1, 3 and 4 channels GpuMat with Byte, UInt16, int or float depth</param>
            <param name="dst">Destination GpuMat. The same source and type as <paramref name="src"/></param>
            <param name="flipType">Specifies how to flip the GpuMat.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseXor(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two GpuMats:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseOr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical or of two GpuMats:
            dst(I)=src1(I) | src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseAnd(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical and of two GpuMats:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseNot(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical not
            dst(I)=~src(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Min(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes per-element minimum of two GpuMats (dst = min(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The second GpuMat</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Max(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes per-element maximum of two GpuMats (dst = max(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The second GpuMat</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Threshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.ThresholdType,Emgu.CV.Cuda.Stream)">
            <summary>
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by thresholdType
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Gemm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.GemmType,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha">The scalar</param>
            <param name="src3">The third source array (shift). Can be IntPtr.Zero, if there is no shift.</param>
            <param name="beta">The scalar</param>
            <param name="dst">The destination array.</param>
            <param name="tABC">The gemm operation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.WarpAffine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            Warps the image using affine transformation
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="M">The 2x3 transformation matrix (pointer to CvArr)</param>
            <param name="flags">Supports NN, LINEAR, CUBIC</param>
            <param name="borderMode">The border mode, use BORDER_TYPE.CONSTANT for default.</param>
            <param name="borderValue">The border value, use new MCvScalar() for default.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.WarpPerspective(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            Warps the image using perspective transformation
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="M">The 2x3 transformation matrix (pointer to CvArr)</param>
            <param name="flags">Supports NN, LINEAR, CUBIC</param>
            <param name="borderMode">The border mode, use BORDER_TYPE.CONSTANT for default.</param>
            <param name="borderValue">The border value, use new MCvScalar() for default.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Remap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            DST[x,y] = SRC[xmap[x,y],ymap[x,y]] with bilinear interpolation.
            </summary>
            <param name="src">The source GpuMat. Supports CV_8UC1, CV_8UC3 source types. </param>
            <param name="dst">The dstination GpuMat. Supports CV_8UC1, CV_8UC3 source types. </param>
            <param name="xmap">The xmap. Supports CV_32FC1 map type.</param>
            <param name="ymap">The ymap. Supports CV_32FC1 map type.</param>
            <param name="interpolation">Interpolation type.</param>
            <param name="borderMode">Border mode. Use BORDER_CONSTANT for default.</param>
            <param name="borderValue">The value of the border.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanShiftFiltering(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs mean-shift filtering for each point of the source image. It maps each point of the source
            image into another point, and as the result we have new color and new position of each point.
            </summary>
            <param name="src">Source CudaImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dst">Destination CudaImage, containing color of mapped points. Will have the same size and type as src.</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="criteria">Termination criteria.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanShiftProc(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs mean-shift procedure and stores information about processed points (i.e. their colors
            and positions) into two images.
            </summary>
            <param name="src">Source CudaImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dstr">Destination CudaImage, containing color of mapped points. Will have the same size and type as src.</param>
            <param name="dstsp">Destination CudaImage, containing position of mapped points. Will have the same size as src and CV 16SC2 type.</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="criteria">Termination criteria.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanShiftSegmentation(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Performs mean-shift segmentation of the source image and eleminates small segments.
            </summary>
            <param name="src">Source CudaImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dst">Segmented Image. Will have the same size and type as src. Note that this is an Image type and not CudaImage type</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="minSize">Minimum segment size. Smaller segements will be merged.</param>
            <param name="criteria">Termination criteria.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Rotate(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.Cuda.Stream)">
            <summary>
            Rotates an image around the origin (0,0) and then shifts it.
            </summary>
            <param name="src">Source image. Supports 1, 3 or 4 channels images with Byte, UInt16 or float depth</param>
            <param name="dst">Destination image with the same type as src. Must be pre-allocated</param>
            <param name="angle">Angle of rotation in degrees</param>
            <param name="xShift">Shift along the horizontal axis</param>
            <param name="yShift">Shift along the verticle axis</param>
            <param name="interpolation">Interpolation method. Only INTER_NEAREST, INTER_LINEAR, and INTER_CUBIC are supported.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CopyMakeBorder(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            Copies a 2D array to a larger destination array and pads borders with the given constant.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image with the same type as src. The size is Size(src.cols+left+right, src.rows+top+bottom).</param>
            <param name="top">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="bottom">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="left">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="right">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="borderType">Border Type</param>
            <param name="value">Border value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Integral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes the integral image and integral for the squared image
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sum">The sum GpuMat, supports only CV_32S source type, but will contain unsigned int values</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SqrIntegral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes squared integral image 
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sqsum">The sqsum GpuMat, supports only CV32F source type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Dft(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.DxtType,Emgu.CV.Cuda.Stream)">
             <summary>
             Performs a forward or inverse discrete Fourier transform (1D or 2D) of floating point matrix.
             Param dft_size is the size of DFT transform.
             
             If the source matrix is not continous, then additional copy will be done,
             so to avoid copying ensure the source matrix is continous one. If you want to use
             preallocated output ensure it is continuous too, otherwise it will be reallocated.
            
             Being implemented via CUFFT real-to-complex transform result contains only non-redundant values
             in CUFFT's format. Result as full complex matrix for such kind of transform cannot be retrieved.
            
             For complex-to-real transform it is assumed that the source matrix is packed in CUFFT's format.
             </summary>
             <param name="src">The source GpuMat</param>
             <param name="dst">The resulting GpuMat of the DST, must be pre-allocated and continious. If single channel, the result is real. If double channel, the result is complex</param>
             <param name="flags">DFT flags</param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.HistEven(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates histogram with evenly distributed bins for single channel source.
            </summary>
            <param name="src">The source GpuMat. Supports CV_8UC1, CV_16UC1 and CV_16SC1 types.</param>
            <param name="hist">Histogram with evenly distributed bins. A GpuMat&lt;int&gt; type.</param>
            <param name="histSize">The size of histogram (number of levels)</param>                                                                                                                                                                                                                                                             
            <param name="lowerLevel">The lower level</param>
            <param name="upperLevel">The upper level</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
            <returns>Histogram with evenly distributed bins</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BlendLinear(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs linear blending of two images.
            </summary>
            <param name="img1">First image. Supports only CV_8U and CV_32F depth.</param>
            <param name="img2">Second image. Must have the same size and the same type as img1 .</param>
            <param name="weights1">Weights for first image. Must have tha same size as img1. Supports only CV_32F type.</param>
            <param name="weights2">Weights for second image. Must have tha same size as img2. Supports only CV_32F type.</param>
            <param name="result">Destination image.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BilateralFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Single,System.Single,Emgu.CV.CvEnum.BorderType,Emgu.CV.Cuda.Stream)">
            <summary>
            Applies bilateral filter to the image.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; should have the same size and the same type as src</param>
            <param name="kernelSize">The diameter of each pixel neighborhood, that is used during filtering.</param>
            <param name="sigmaColor">Filter sigma in the color space. Larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color</param>
            <param name="sigmaSpatial">Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.</param>
            <param name="borderType">Pixel extrapolation method, use DEFAULT for default</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GammaCorrection(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Routines for correcting image color gamma
            </summary>
            <param name="src">Source image (3- or 4-channel 8 bit).</param>
            <param name="dst">Destination image.</param>
            <param name="forward">True for forward gamma correction or false for inverse gamma correction.</param>
            <param name="stream">Stream for the asynchronous version.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatRelease(System.IntPtr@)">
            <summary>
            Release the GpuMat
            </summary>
            <param name="mat">Pointer to the GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreateDefault">
            <summary>
            Create an empty GpuMat 
            </summary>
            <returns>Pointer to an empty GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreateFromInputArray(System.IntPtr)">
            <summary>
            Convert a CvArr to a GpuMat
            </summary>
            <param name="arr">Pointer to a CvArr</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatGetSize(System.IntPtr)">
            <summary>
            Get the GpuMat size:
            width == number of columns, height == number of rows
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <returns>The size of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatGetType(System.IntPtr)">
            <summary>
            Get the GpuMat type
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <returns>The GpuMat type</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreate(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="type">The type of GpuMat</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreateContinuous(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size. The allocated data is continuous within this GpuMat.
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="type">The type of GpuMat</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatUpload(System.IntPtr,System.IntPtr)">
            <summary>
            Pefroms blocking upload data to GpuMat.
            </summary>
            <param name="gpuMat">The destination gpuMat</param>
            <param name="arr">The CvArray to be uploaded to GPU</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatDownload(System.IntPtr,System.IntPtr)">
            <summary>
            Downloads data from device to host memory. Blocking calls.
            </summary>
            <param name="gpuMat">The source GpuMat</param>
            <param name="arr">The CvArray where data will be downloaded to</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCopyTo(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copy the source GpuMat to destination GpuMat, using an optional mask.
            </summary>
            <param name="src">The GpuMat to be copied from</param>
            <param name="dst">The GpuMat to be copied to</param>
            <param name="mask">The optional mask, use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatConvertTo(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.DepthType,System.Double,System.Double,System.IntPtr)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one GpuMat to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel GpuMats are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination GpuMat element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate convertTo synonym.
            </summary>
            <param name="src">Source GpuMat</param>
            <param name="dst">Destination GpuMat</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source GpuMat elements</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Changes shape of GpuMat without copying data.
            </summary>
            <param name="src">The GpuMat to be reshaped.</param>
            <param name="dst">The result GpuMat.</param>
            <param name="newCn">New number of channels. newCn = 0 means that the number of channels remains unchanged.</param>
            <param name="newRows">New number of rows. newRows = 0 means that the number of rows remains unchanged unless it needs to be changed according to newCn value.</param>
            <returns>A GpuMat of different shape</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaTemplateMatchingMatch(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="tm">Pointer to cv::gpu::TemplateMatching</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>  
        </member>
        <member name="P:Emgu.CV.Cuda.CudaInvoke.HasCuda">
            <summary>
            Return true if Cuda is found on the system
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2">
            <summary>
            Gaussian Mixture-based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary>
            Create a Gaussian Mixture-based Background/Foreground Segmentation model
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2.Update(Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaCascadeClassifier">
            <summary>
            Cascade Classifier for object detection using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.#ctor(System.String)">
            <summary>
            Create a Cuda cascade classifier using the specific file
            </summary>
            <param name="fileName">The file to create the classifier from</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.DetectMultiScale(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles.
            </summary>
            <param name="image">The image where search will take place</param>
            <returns>An array of regions for the detected objects</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaClahe">
            <summary>
            Contrast Limited Adaptive Histogram Equalization
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaClahe.#ctor(System.Double,System.Drawing.Size)">
            <summary>
            Create the Contrast Limited Adaptive Histogram Equalization
            </summary>
            <param name="clipLimit">Threshold for contrast limiting. Use 40.0 for default</param>
            <param name="tileGridSize">Size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles. This parameter defines the number of tiles in row and column. Use (8, 8) for default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaClahe.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization.
            </summary>
            <param name="source">Source image</param>
            <param name="dst">Destination image</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaClahe.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDeviceInfo">
            <summary>
            The Cuda device information
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.#ctor">
            <summary>
            Query the information of the gpu device that is currently in use.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.#ctor(System.Int32)">
            <summary>
            Query the information of the cuda device with the specific id.
            </summary>
            <param name="deviceId">The device id</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.Supports(Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature)">
            <summary>
            Indicates if the decive has the specific feature
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.DisposeObject">
            <summary>
            Release the unmanaged resource related to the GpuDevice
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.ID">
            <summary>
            The id of the device
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.Name">
            <summary>
            The name of the device
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.CudaComputeCapability">
            <summary>
            The compute capability
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.MultiProcessorCount">
            <summary>
            The number of single multi processors
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.FreeMemory">
            <summary>
            Get the amount of free memory at the moment
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.TotalMemory">
            <summary>
            Get the amount of total memory
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.IsCompatible">
            <summary>
            Checks whether the Cuda module can be run on the given device
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature">
            <summary>
            GPU feature
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute10">
            <summary>
            Cuda compute 1.0
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute11">
            <summary>
            Cuda compute 1.1
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute12">
            <summary>
            Cuda compute 1.2
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute13">
            <summary>
            Cuda compute 1.3
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute20">
            <summary>
            Cuda compute 2.0
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute21">
            <summary>
            Cuda compute 2.1
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.GlobalAtomics">
            <summary>
            Global Atomic
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.SharedAtomics">
            <summary>
            Shared Atomic
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.NativeDouble">
            <summary>
            Native double
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHOG">
            <summary>
            A HOG descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.#ctor(System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32)">
            <summary>
            Create a new HOGDescriptor using the specific parameters
            </summary>
            <param name="blockSize">Block size in cells. Use (16, 16) for default.</param>
            <param name="cellSize">Cell size. Use (8, 8) for default.</param>
            <param name="blockStride">Block stride. Must be a multiple of cell size. Use (8,8) for default.</param>
            <param name="nbins">Number of bins.</param>
            <param name="winSize">Detection window size. Must be aligned to block size and block stride. Must match the size of the training image. Use (64, 128) for default.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.GetDefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
            <returns>The default people detector</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.SetSVMDetector(Emgu.CV.IInputArray)">
            <summary>
            Set the SVM detector 
            </summary>
            <param name="detector">The SVM detector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this HOGDescriptor
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaImage`2">
            <summary>
            An CudaImage is very similar to the Emgu.CV.Image except that it is being used for GPU processing
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="T:Emgu.CV.Cuda.GpuMat`1">
            <summary>
            Similar to CvArray but use GPU for processing
            </summary>
            <typeparam name="TDepth">The type of element in the matrix</typeparam>
        </member>
        <member name="T:Emgu.CV.Cuda.GpuMat">
            <summary>
            A GpuMat, use the generic version if possible. The non generic version is good for use as buffer in stream calls.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor">
            <summary>
            Create an empty GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Boolean)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="channels">The number of channels</param>
            <param name="depthType">The type of depth</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create a GpuMat from the specific pointer
            </summary>
            <param name="ptr">Pointer to the unmanaged gpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create a GpuMat from an CvArray of the same depth type
            </summary>
            <param name="arr">The CvArry to be converted to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(Emgu.CV.Cuda.GpuMat,Emgu.CV.Structure.MCvSlice,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Create a GpuMat from the specific region of <paramref name="mat"/>. The data is shared between the two GpuMat
            </summary>
            <param name="mat">The matrix where the region is extracted from</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Upload(Emgu.CV.IInputArray)">
            <summary>
            Performs blocking upload data to GpuMat
            </summary>
            <param name="arr">The CvArray to be uploaded to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Download(Emgu.CV.IOutputArray)">
            <summary>
            Downloads data from device to host memory. Blocking calls
            </summary>
            <param name="arr">The destination CvArray where the GpuMat data will be downloaded to.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Copies scalar value to every selected element of the destination GpuMat:
            arr(I)=value if mask(I)!=0
            </summary>
            <param name="value">Fill value</param>
            <param name="mask">Operation mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Can be IntPtr.Zero if not used</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Copy the source GpuMat to destination GpuMat, using an optional mask.
            </summary>
            <param name="dst">The output array to be copied to</param>
            <param name="mask">The optional mask, use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one GpuMat to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel GpuMats are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination GpuMat element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate convertTo synonym.
            </summary>
            <param name="dst">Destination GpuMat</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source GpuMat elements</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes shape of GpuMat without copying data.
            </summary>
            <param name="newCn">New number of channels. newCn = 0 means that the number of channels remains unchanged.</param>
            <param name="newRows">New number of rows. newRows = 0 means that the number of rows remains unchanged unless it needs to be changed according to newCn value.</param>
            <returns>A GpuMat of different shape</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Row(System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the ith row of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="i">The row to be extracted</param>
            <returns>The ith row of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.RowRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the [<paramref name="start"/> <paramref name="end"/>) rows of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="start">The inclusive stating row to be extracted</param>
            <param name="end">The exclusive ending row to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) rows of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Col(System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the ith column of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="i">The column to be extracted</param>
            <returns>The ith column of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.ColRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the [<paramref name="start"/> <paramref name="end"/>) columns of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="start">The inclusive stating column to be extracted</param>
            <param name="end">The exclusive ending column to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) columns of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Equals(Emgu.CV.Cuda.GpuMat)">
            <summary>
            Returns true if the two GpuMat equals
            </summary>
            <param name="other">The other GpuMat to be compares with</param>
            <returns>True if the two GpuMat equals</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.MergeFrom(Emgu.CV.Cuda.GpuMat[],Emgu.CV.Cuda.Stream)">
             <summary>
             Makes multi-channel array out of several single-channel arrays
             </summary>
            <param name="gpuMats"> 
            An array of single channel GpuMat where each item
            in the array represent a single channel of the GpuMat 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.SplitInto(Emgu.CV.Cuda.GpuMat[],Emgu.CV.Cuda.Stream)">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <param name="gpuMats"> 
            An array of single channel GpuMat where each item
            in the array represent a single channel of the original GpuMat 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Split(Emgu.CV.Cuda.Stream)">
            <summary> 
            Split current GpuMat into an array of single channel GpuMat where each element 
            in the array represent a single channel of the original GpuMat
            </summary>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns> 
            An array of single channel GpuMat where each element  
            in the array represent a single channel of the original GpuMat 
            </returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Size">
            <summary>
            Get the GpuMat size:
            width == number of columns, height == number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Type">
            <summary>
            Get the type of the GpuMat
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.IsContinuous">
            <summary>
            True if the data is continues
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.IsEmpty">
            <summary>
            True if the matrix is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create a GpuMat from the unmanaged pointer
            </summary>
            <param name="ptr">The unmanaged pointer to the GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor">
            <summary>
            Create an empty GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create a GpuMat from an CvArray of the same depth type
            </summary>
            <param name="arr">The CvArry to be converted to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="channels">The number of channels</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(System.Drawing.Size,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="size">The size of the GpuMat</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.ToMatrix">
            <summary>
            Convert this GpuMat to a Matrix
            </summary>
            <returns>The matrix that contains the same values as this GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Returns a GpuMat corresponding to a specified rectangle of the current GpuMat. The data is shared with the current matrix. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="region">Zero-based coordinates of the rectangle of interest.</param>
            <returns>A GpuMat that represent the region of the current matrix.</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat the represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor">
            <summary>
            Create an empty CudaImage
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create the CudaImage from the unmanaged pointer.
            </summary>
            <param name="ptr">The unmanaged pointer to the GpuMat. It is the user's responsibility that the Color type and depth matches between the managed class and unmanaged pointer.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create a GPU image from a regular image
            </summary>
            <param name="img">The image to be converted to GPU image</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a CudaImage of the specific size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a CudaImage of the specific size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a CudaImage of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(Emgu.CV.Cuda.CudaImage{`0,`1},Emgu.CV.Structure.MCvSlice,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Create a CudaImage from the specific region of <paramref name="image"/>. The data is shared between the two CudaImage
            </summary>
            <param name="image">The CudaImage where the region is extracted from</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.ToImage">
            <summary>
            Convert the current CudaImage to a regular Image.
            </summary>
            <returns>A regular image</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Convert``2">
            <summary> Convert the current CudaImage to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns>CudaImage of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.ConvertFrom``2(Emgu.CV.Cuda.CudaImage{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Clone(Emgu.CV.Cuda.Stream)">
            <summary>
            Create a clone of this CudaImage
            </summary>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>A clone of this CudaImage</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Resize(System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.Cuda.Stream)">
            <summary>
            Resize the CudaImage. The calling GpuMat be GpuMat%lt;Byte&gt;. If stream is specified, it has to be either 1 or 4 channels.
            </summary>
            <param name="size">The new size</param>
            <param name="interpolationType">The interpolation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>A CudaImage of the new size</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Returns a CudaImage corresponding to a specified rectangle of the current CudaImage. The data is shared with the current matrix. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="region">Zero-based coordinates of the rectangle of interest.</param>
            <returns>A CudaImage that represent the region of the current CudaImage.</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Row(System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the ith row of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="i">The row to be extracted</param>
            <returns>The ith row of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.RowRange(System.Int32,System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the [<paramref name="start"/> <paramref name="end"/>) rows of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="start">The inclusive stating row to be extracted</param>
            <param name="end">The exclusive ending row to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) rows of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Col(System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the ith column of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="i">The column to be extracted</param>
            <returns>The ith column of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.ColRange(System.Int32,System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the [<paramref name="start"/> <paramref name="end"/>) columns of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="start">The inclusive stating column to be extracted</param>
            <param name="end">The exclusive ending column to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) columns of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaImage`2.Bitmap">
             <summary>
             convert the current CudaImage to its equivalent Bitmap representation
             </summary>
            
        </member>
        <member name="T:Emgu.CV.Cuda.CudaLookUpTable">
            <summary>
            Gpu look up table
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLookUpTable.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create the look up table
            </summary>
            <param name="lookUpTable">It should be either 1 or 3 channel matrix of 1x256</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLookUpTable.Transform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Transform the image using the lookup table
            </summary>
            <param name="image">The image to be transformed</param>
            <param name="dst">The transformation result</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLookUpTable.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this look up table
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.DescriptorMatcher">
            <summary>
            Descriptor matcher
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.DescriptorMatcher.KnnMatch(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Int32,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Find the k-nearest match
            </summary>
            <param name="queryDescriptors">An n x m matrix of descriptors to be query for nearest neighbors. n is the number of descriptor and m is the size of the descriptor</param>
            <param name="k">Number of nearest neighbors to search for</param>
            <param name="mask">Can be null if not needed. An n x 1 matrix. If 0, the query descriptor in the corresponding row will be ignored.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.DescriptorMatcher.Add(Emgu.CV.IInputArray)">
            <summary>
            Add the model descriptors
            </summary>
            <param name="modelDescriptors">The model descriptors</param>
        </member>
        <member name="M:Emgu.CV.Cuda.DescriptorMatcher.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBFMatcher">
            <summary>
            A Brute force matcher using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBFMatcher.#ctor(Emgu.CV.Features2D.DistanceType)">
            <summary>
            Create a CudaBruteForceMatcher using the specific distance type
            </summary>
            <param name="distanceType">The distance type</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaFastFeatureDetector">
            <summary>
            A FAST detector using Cuda
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.IFeature2DAsync">
            <summary>
            The feature 2D base class
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.IFeature2DAsync.Feature2DAsyncPtr">
            <summary>
            Get the pointer to the Feature2DAsync object
            </summary>
            <returns>The pointer to the Feature2DAsync object</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFastFeatureDetector.#ctor(System.Int32,System.Boolean,Emgu.CV.Features2D.FastDetector.DetectorType,System.Int32)">
            <summary>
            Create a fast detector with the specific parameters
            </summary>
            <param name="threshold">Threshold on difference between intensity of center pixel and pixels on circle around
            this pixel. Use 10 for default.</param>
            <param name="nonmaxSupression">Specifiy if non-maximum supression should be used.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFastFeatureDetector.DisposeObject">
            <summary>
            Release the unmanaged resource associate to the Detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaORBDetector">
            <summary>
            An ORB detector using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaORBDetector.#ctor(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.Features2D.ORBDetector.ScoreType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a ORBDetector using the specific values
            </summary>
            <param name="numberOfFeatures">The number of desired features.</param>
            <param name="scaleFactor">Coefficient by which we divide the dimensions from one scale pyramid level to the next.</param>
            <param name="nLevels">The number of levels in the scale pyramid.</param>
            <param name="firstLevel">The level at which the image is given. If 1, that means we will also look at the image.<paramref name="scaleFactor"/> times bigger</param>
            <param name="edgeThreshold">How far from the boundary the points should be.</param>
            <param name="WTK_A">How many random points are used to produce each cell of the descriptor (2, 3, 4 ...).</param>
            <param name="scoreType">Type of the score to use.</param>
            <param name="patchSize">Patch size.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaORBDetector.DisposeObject">
            <summary>
            Release the unmanaged resource associate to the Detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.DetectAndComputeAsync(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Detect keypoints in an image and compute the descriptors on the image from the keypoint locations.
            </summary>
            <param name="image">The image</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The detected keypoints will be stored in this vector</param>
            <param name="descriptors">The descriptors from the keypoints</param>
            <param name="useProvidedKeyPoints">If true, the method will skip the detection phase and will compute descriptors for the provided keypoints</param>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.DetectAsync(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Detect the features in the image
            </summary>
            <param name="keypoints">The result vector of keypoints</param>
            <param name="image">The image from which the features will be detected from</param>
            <param name="mask">The optional mask.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.ComputeAsync(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Compute the descriptors on the image from the given keypoint locations.
            </summary>
            <param name="image">The image to compute descriptors from</param>
            <param name="keypoints">The keypoints where the descriptor computation is perfromed</param>
            <param name="descriptors">The descriptors from the given keypoints</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBoxMaxFilter">
            <summary>
            BoxMax filter
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaFilter">
            <summary>
            Base Cuda filter class
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFilter.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this gpu filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFilter.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Apply the cuda filter
            </summary>
            <param name="image">The source CudaImage where the filter will be applied to</param>
            <param name="dst">The destination CudaImage</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBoxMaxFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a BoxMax filter.
            </summary>
            <param name="ksize">Size of the kernel</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBoxMinFilter">
            <summary>
            BoxMin filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBoxMinFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a BoxMin filter.
            </summary>
            <param name="ksize">Size of the kernel</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaGaussianFilter">
            <summary>
            Gaussian filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGaussianFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.BorderType,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Create a Gaussian filter.
            </summary>
            <param name="ksize">The size of the kernel</param>
            <param name="sigma1">This parameter may specify Gaussian sigma (standard deviation). If it is zero, it is calculated from the kernel size.</param>
            <param name="sigma2">In case of non-square Gaussian kernel the parameter may be used to specify a different (from param3) sigma in the vertical direction. Use 0 for default</param>
            <param name="rowBorderType">The row border type.</param>
            <param name="columnBorderType">The column border type.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaLaplacianFilter">
            <summary>
            Laplacian filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLaplacianFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a Laplacian filter.
            </summary>
            <param name="ksize">Either 1 or 3</param>
            <param name="scale">Optional scale. Use 1.0 for default</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaLinearFilter">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLinearFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.IInputArray,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a Gpu LinearFilter
            </summary>
            <param name="kernel">Convolution kernel, single-channel floating point matrix (e.g. Emgu.CV.Matrix). If you want to apply different kernels to different channels, split the gpu image into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
            <param name="borderType">Border type. Use REFLECT101 as default.</param>
            <param name="borderValue">The border value</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaMorphologyFilter">
            <summary>
            Morphology filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaMorphologyFilter.#ctor(Emgu.CV.CvEnum.MorphOp,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32)">
            <summary>
            Create a Morphology filter.
            </summary>
            <param name="op">Type of morphological operation</param>
            <param name="kernel">2D 8-bit structuring element for the morphological operation.</param>
            <param name="anchor">Anchor position within the structuring element. Negative values mean that the anchor is at the center.</param>
            <param name="iterations">Number of times erosion and dilation to be applied.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaSobelFilter">
            <summary>
            Sobel filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaSobelFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Create a Sobel filter.
            </summary>
            <param name="dx">Order of the derivative x</param>
            <param name="dy">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel</param>
            <param name="scale">Optional scale, use 1 for default.</param>
            <param name="rowBorderType">The row border type.</param>
            <param name="columnBorderType">The column border type.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaCannyEdgeDetector">
            <summary>
            Cascade Classifier for object detection using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCannyEdgeDetector.#ctor(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Canny edge detector using Cuda.
            </summary>
            <param name="lowThreshold">The first threshold, used for edge linking</param>
            <param name="highThreshold">The second threshold, used to find initial segments of strong edges</param>
            <param name="apertureSize">Aperture parameter for Sobel operator, use 3 for default</param>
            <param name="L2gradient">Use false for default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCannyEdgeDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds the edges on the input <paramref name="src"/> and marks them in the output image edges using the Canny algorithm. 
            </summary>
            <param name="src">Input image</param>
            <param name="edges">Image to store the edges found by the function</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCannyEdgeDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associate with this Canny edge detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaCornernessCriteria">
            <summary>
            Base CornernessCriteria class
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCornernessCriteria.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this gpu filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCornernessCriteria.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Apply the cuda filter
            </summary>
            <param name="image">The source CudaImage where the filter will be applied to</param>
            <param name="dst">The destination CudaImage</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector">
            <summary>
            Cuda implementation of GoodFeaturesToTrackDetector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Create the Cuda implementation of GoodFeaturesToTrackDetector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Find the good features to track
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHarrisCorner">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHarrisCorner.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Create a Cuda Harris Corner detector
            </summary>
            <param name="blockSize">Neighborhood size </param>
            <param name="kSize"></param>
            <param name="k">Harris detector free parameter.</param>
            <param name="borderType">Boreder type, use REFLECT101 for default</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHoughCirclesDetector">
            <summary>
            Base class for circles detector algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughCirclesDetector.#ctor(System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create hough circles detector
            </summary>
            <param name="dp">Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height.</param>
            <param name="minDist">Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.</param>
            <param name="cannyThreshold">The higher threshold of the two passed to Canny edge detector (the lower one is twice smaller).</param>
            <param name="votesThreshold">The accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected.</param>
            <param name="minRadius">Minimum circle radius.</param>
            <param name="maxRadius">Maximum circle radius.</param>
            <param name="maxCircles">Maximum number of output circles.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughCirclesDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds circles in a grayscale image using the Hough transform.
            </summary>
            <param name="image">8-bit, single-channel grayscale input image.</param>
            <param name="circles">Output vector of found circles. Each vector is encoded as a 3-element floating-point vector.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughCirclesDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this circle detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHoughLinesDetector">
            <summary>
            Base class for lines detector algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughLinesDetector.#ctor(System.Single,System.Single,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Create a hough lines detector
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt; threshold).</param>
            <param name="doSort">Performs lines sort by votes.</param>
            <param name="maxLines">Maximum number of output lines.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughLinesDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image</param>
            <param name="lines">Output vector of lines.Output vector of lines. Each line is represented by a two-element vector. 
            The first element is the distance from the coordinate origin (top-left corner of the image). 
            The second element is the line rotation angle in radians.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughLinesDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated to this line detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHoughSegmentDetector">
            <summary>
            Base class for line segments detector algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughSegmentDetector.#ctor(System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a hough segment detector
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="minLineLength"> Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxLineGap">Maximum allowed gap between points on the same line to link them.</param>
            <param name="maxLines">Maximum number of output lines.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughSegmentDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image</param>
            <param name="lines">Output vector of lines. Each line is represented by a 4-element vector (x1, y1, x2, y2) , where (x1, y1) and (x2, y2) are the ending points of each detected line segment.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughSegmentDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this segment detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaTemplateMatching">
            <summary>
            Cuda template matching filter.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaTemplateMatching.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.TemplateMatchingType,System.Drawing.Size)">
            <summary>
            Create a Cuda template matching filter
            </summary>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <param name="blockSize">The block size</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaTemplateMatching.Match(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
             This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaTemplateMatching.DisposeObject">
            <summary>
            Release the buffer
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD">
            <summary>
            Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a Background/Foreground Segmentation model
            </summary>
            <param name="Lc"></param>
            <param name="N1c"></param>
            <param name="N2c"></param>
            <param name="Lcc"></param>
            <param name="N1cc"></param>
            <param name="N2cc"></param>
            <param name="isObjWithoutHoles"></param>
            <param name="performMorphing"></param>
            <param name="alpha1">Background reference image update parameter</param>
            <param name="alpha2">Stat model update parameter. 0.002f ~ 1K frame(~45sec), 0.005 ~ 18sec (if 25fps and absolutely static BG)</param>
            <param name="alpha3">start value for alpha parameter (to fast initiate statistic model)</param>
            <param name="delta"></param>
            <param name="T"></param>
            <param name="minArea"></param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG">
            <summary>
            Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG.#ctor(System.Int32,System.Double)">
            <summary>
            Create a Background/Foreground Segmentation model
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBroxOpticalFlow">
            <summary>
            Brox optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBroxOpticalFlow.#ctor(System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create the Brox optical flow solver
            </summary>
            <param name="alpha">Flow smoothness</param>
            <param name="gamma">Gradient constancy importance</param>
            <param name="scaleFactor">Pyramid scale factor</param>
            <param name="innerIterations">Number of lagged non-linearity iterations (inner loop)</param>
            <param name="outerIterations">Number of warping iterations (number of pyramid levels)</param>
            <param name="solverIterations">Number of linear system solver iterations</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBroxOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDensePyrLKOpticalFlow">
            <summary>
            PyrLK optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDensePyrLKOpticalFlow.#ctor(System.Drawing.Size,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create the PyrLK optical flow solver
            </summary>
            <param name="winSize">Windows size. Use 21x21 for default</param>
            <param name="maxLevel">The maximum number of pyramid levels.</param>
            <param name="iters">The number of iterations.</param>
            <param name="useInitialFlow">Weather or not use the initial flow in the input matrix.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDensePyrLKOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaFarnebackOpticalFlow">
            <summary>
            Farneback optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFarnebackOpticalFlow.#ctor(System.Int32,System.Double,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="numLevels"></param>
            <param name="pyrScale"></param>
            <param name="fastPyramids"></param>
            <param name="winSize"></param>
            <param name="numIters"></param>
            <param name="polyN"></param>
            <param name="polySigma"></param>
            <param name="flags"></param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFarnebackOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1">
            <summary>
            DualTvl1 optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1.#ctor(System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1"/> class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaSparsePyrLKOpticalFlow">
            <summary>
            Sparse PyrLK optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaSparsePyrLKOpticalFlow.#ctor(System.Drawing.Size,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create the PyrLK optical flow solver
            </summary>
            <param name="winSize">Windows size. Use 21x21 for default</param>
            <param name="maxLevel">The maximum number of pyramid levels.</param>
            <param name="iters">The number of iterations.</param>
            <param name="useInitialFlow">Weather or not use the initial flow in the input matrix.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaSparsePyrLKOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDisparityBilateralFilter">
            <summary>
            Disparity map refinement using joint bilateral filtering given a single color image.
            Qingxiong Yang, Liang Wang, Narendra Ahuja
            http://vision.ai.uiuc.edu/~qyang6/
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDisparityBilateralFilter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuDisparityBilateralFilter
            </summary>
            <param name="ndisp">Number of disparities. Use 64 as default</param>
            <param name="radius">Filter radius, use 3 as default</param>
            <param name="iters">Number of iterations, use 1 as default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDisparityBilateralFilter.Apply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Apply the filter to the disparity image
            </summary>
            <param name="disparity">The input disparity map</param>
            <param name="image">The image</param>
            <param name="dst">The output disparity map, should have the same size as the input disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDisparityBilateralFilter.DisposeObject">
            <summary>
            Release the unmanaged resources associated with the filter.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaStereoBM">
            <summary>
            Use Block Matching algorithm to find stereo correspondence
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoBM.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a stereoBM 
            </summary>
            <param name="numberOfDisparities">The number of disparities. Must be multiple of 8. Use 64 for default </param>
            <param name="blockSize">The SAD window size. Use 19 for default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoBM.FindStereoCorrespondence(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoBM.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaStereoConstantSpaceBP">
            <summary>
            A Constant-Space Belief Propagation Algorithm for Stereo Matching.
            Qingxiong Yang, Liang Wang, Narendra Ahuja.
            http://vision.ai.uiuc.edu/~qyang6/
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoConstantSpaceBP.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A Constant-Space Belief Propagation Algorithm for Stereo Matching
            </summary>
            <param name="ndisp">The number of disparities. Use 128 as default</param>
            <param name="iters">The number of BP iterations on each level. Use 8 as default.</param>
            <param name="levels">The number of levels. Use 4 as default</param>
            <param name="nrPlane">The number of active disparity on the first level. Use 4 as default.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoConstantSpaceBP.FindStereoCorrespondence(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoConstantSpaceBP.DisposeObject">
            <summary>
            Release the unmanaged memory
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.Stream">
            <summary>
            Encapculates Cuda Stream. Provides interface for async coping.
            Passed to each function that supports async kernel execution.
            Reference counting is enabled
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Stream.#ctor">
            <summary>
            Create a new Cuda Stream
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Stream.WaitForCompletion">
            <summary>
            Wait for the completion
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Stream.DisposeObject">
            <summary>
            Release the stream
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.Stream.Completed">
            <summary>
            Check if the stream is completed
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.TargetArchs">
            <summary>
            Gives information about what GPU archs this OpenCV GPU module was compiled for
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.BuildWith(Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature)">
            <summary>
            Check if the GPU module is build with the specific feature set.
            </summary>
            <param name="featureSet">The feature set to be checked.</param>
            <returns>True if the GPU module is build with the specific feature set.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.Has(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for the specific device version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for the specific device version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasPtx(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for the specific PTX version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for the specific PTX version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasBin(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for the specific BIN version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for the specific BIN version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrLessPtx(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or less PTX version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or less PTX version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrGreater(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or greater device version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or greater device version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrGreaterPtx(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or greater PTX version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or greater PTX version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrGreaterBin(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or greater BIN version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or greater BIN version.</returns>
        </member>
        <member name="T:Emgu.CV.Cuda.VectorOfGpuMat">
            <summary>
            Wrapped class of the C++ standard vector of GpuMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.#ctor">
            <summary>
            Create an empty standard vector of GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of GpuMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.#ctor(Emgu.CV.Cuda.GpuMat[])">
            <summary>
            Create an standard vector of GpuMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Push(Emgu.CV.Cuda.GpuMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Push(Emgu.CV.Cuda.GpuMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.VectorOfGpuMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.VectorOfGpuMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
    </members>
</doc>
